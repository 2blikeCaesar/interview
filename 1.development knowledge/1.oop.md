# 객체지향 프로그래밍 (Object Oriented Programming)


## 1. 절차지향 프로그래밍

객체지향 프로그래밍이 나오기 전 초기 프로그래밍 방식으로

순차적인 명령 수행 뿐만 아니라 루틴, 메소드, 함수 등을 이용한 프로그래밍 패러다임이다.

프로시저를 이용하여 프로그래밍을 하게 되면 함수 호출을 통해서 재사용성이 높아지게 되고

프로그램 흐름을 쉽게 볼 수 있고 가독성이 높아질 수 있다.

순차적인 처리가 중요시 되면서 유기적으로 연결 되도록 만드는 프로그래밍 기법이며

가장 대표적인 언어로는 C가 존재한다.

ㅇ
## 2. 객체지향 프로그래밍

초기에는 절자치향 프로그래밍에 비해 매우 이질적이고 컴퓨터 성능이 좋지 못해서 주목을 받지 못하였다.

하지만 하드웨어의 성능이 발전하고 GUI의 등장으로 인해서 이벤트 처리 수행이 필요하게 되었다.


> 실 세계를 모델링 한다.

객체 지향에서는 실제 세계를 모델링 한다고 하는데

이는 데이터와 절차를 하나의 덩어리로 묶어서 생각하는 것을 의미한다.

즉 필요한 데이터를 추상화 시켜 상태와 행위를 가진 객체를 만들고 객체들간의 상호작용을 통해 로직을 구성하는 기법이다.

### 2.1 객체 지향의 3대 요소

* 캡슐화 - 캡슐화는 프로그램의 구현을 외부로 드러나지 않도록 감추는 것을 의미한다. 특정 메소드를 통해서만 접근이 가능하기 때문에 응집도는 높이고 결합도는 떨어트릴 수 있다.

* 상속 - 상속은 이미 작성 된 클래스를 상속 받아서 새로운 클래스를 만드는 기법으로 기존 코드를 재 활용할 수 있다.
이러한 상속 관계를 통해서 객체들을 조직화 할 수 있는 장점이 있다.
재 활용 뿐만 아니라 상속받은 기능을 필요에 따라서 수정 즉 오버라이딩 하여 사용이 가능하다.

* 다형성 - 한 요소에 여러 개념을 넣어 놓는 것을 의미한다. 예를 들어서 오버라이딩이나 오버로딩이 존재한다. 개념적으로 동일한 작업을 하는 메소드들의 이름을 통일 시키면 가독성이 높아지는 효과가 존재한다.


소프트웨어 공학 관점에서 볼 때 응집력은 높이고 결합력은 약하게 하는 장점이 존재합니다.

그 뿐 아니라 개발자가 만든 데이터를 사용하기에 신뢰성 있다. 이는 클래스 자체가 오로지 관련 데이터만을 정의하고 다른 프로그램의 데이터를 건들수 없기 때문이다.

잘 만들어진 클래스는 재사용성을 보장 할 수 있다.
단순히 클래스 재사용 뿐만 아니라 상속 기능을 통해서 기능을 확장 할 수 있다.

그 뿐 아니라 객체 단위로 코드가 나뉘어져 작성 되기 때문에 디버깅이 쉽고 유지보수가 용이하다.


단점으로는 객체간의 정보 교환이 메시지 교환을 통해 일어나기 때문에 많은 오버헤드가 발생 할 수 있다.

### 2.2 객체 지향 설계 원칙

SOLID라고 하며 아래와 같이 정의 된다.

* SRP(Single Responsibility Principle) - 단일 책임 원칙

  * 작성 된 클래스는 하나의 기능만 가지며 클래스가 제공하는 모든 서비스는 하나의 책임 즉 기능을 수행하는데 집중 되어 있어야 한다는 원칙이다.
  클래스에 하나의 책임만 부여하기 때문에 코드 변경에 있어서 연쇄작용이 일어나지 않는다. 뿐만 아니라 하나의 책임만 가지고 있기에 가독성, 유지보수에도 좋은 영향을 끼친다.
  가장 단순해 보이는 원칙이지만 설계하기 어렵다. 실무의 프로세스는 복잡하고 수정도 자주 일어나기 때문에 도메인에 대한 이해가 부족하면 힘들기 때문이다.
  클래스 분리시에 책임만 분리하는 것이 아니라 분리 된 두 클래스간의 복잡도를 줄이도록 설계해야 한다. 만약 분리 된 클래스끼리 유사하고 비슷한 책임을 중복해서 가지고 있다면 분리된 슈퍼 클래스를 통해서 상속을 받게 함이 좋은 방법이다. 즉 유사한 책임 부모에게 위임을 해야 한다.

* OCP(Open Close Principle) - 개방 폐쇄 원칙

  * 확장에는 열려 있고 변경에는 닫혀 있어야 한다는 의미이다. 즉 요구 사항의 변경이나 추가사항이 발생하여도 기존 구성요소는 수정이 일어나서는 안되고 기존 구성요소를 확장해서 재사용하라는 의미이다. 확장 될 것과 변하지 않을 것을 확실히 구분한다.

* LSP(Liskov Substitution Principle) - 리스코프 치환 원칙

  * 서브 타입은 언제나 기반이 되는 타입으로 교체가 될 수 있다는 의미이다. 서브 타입은 기반이 되는 타입이 약속한 규약을 지켜야 한다.

* ISP(Interface Segregation Principle) - 인터페이스 분리 원칙

  * 특정 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원리이다.

* DIP(Dependency Inversion Principle) - 의존성 역전 법칙

  * 상위클래스는 하위 클래스에 의존해서는 안된다는 법칙. 또 다른 의미로 의존관계에서 있어서 변화가 쉬운 것 보다는 변화가 없는 것에 의존해야 한다.


ㅇ
